# stephanie/data/plan_trace.py
import os
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union
from stephanie.scoring.score_bundle import ScoreBundle

@dataclass
class ExecutionStep:
    """
    Represents a single step in the execution of a reasoning plan.
    This can be generated by an executor like EpistemicPlanExecutorAgent.
    """
    step_id: Union[str, int]  # Unique identifier for the step (e.g., index, name)
    description: str  # A textual description of what this step does
    output_text: str  # The textual output or result of this step

    # The scores assigned to this step's output by various scorers (SICQL, EBT, etc.)
    # against the original goal. 
    scores: ScoreBundle 

    plan_trace_id: Optional[int] = None  # Foreign key to the PlanTrace this step belongs to
    step_order: Optional[int] = None  # Foreign key to the PlanTrace this step belongs to
    # Optional: Embedding of the output_text. Can be computed on demand if not stored.
    output_embedding: Optional[List[float]] = None 
    
    # Optional: Any other metadata specific to this step
    extra_data: Dict[str, Any] = field(default_factory=dict) 


@dataclass
class PlanTrace:
    """
    Represents the complete execution trace of a reasoning plan.
    This is the primary input for the EpistemicTraceEncoder and subsequently 
    the Epistemic Plan HRM model.
    """
    # --- Core Identifiers ---
    trace_id: str # Unique identifier for this specific trace/execution
    
    # --- Initial Context ---
    goal_text: str # The original goal or query
    goal_id: int
    goal_embedding: List[float] # The embedding vector for the goal_text
    input_data: Dict[str, Any] # Any initial data or variables provided to the plan
    
    # --- Plan Definition (Optional but useful for context) ---
    # This could be a representation of the DSPy program or pipeline used.
    # A simple string signature or a more structured representation.
    plan_signature: str 

    # --- Execution Details ---
    execution_steps: List[ExecutionStep] # The sequence of steps executed
    
    # --- Final Outcome ---
    final_output_text: str # The final output produced by the plan
    # The scores assigned to the final output by various scorers.
    final_scores: ScoreBundle 
    # Optional: Embedding of the final_output_text. Can be computed on demand.
    final_output_embedding: Optional[List[float]] = None 

    # --- Target for Epistemic Plan HRM Training ---
    # This is the label the HRM model will try to predict.
    # It represents the "epistemic quality" of this reasoning process.
    target_epistemic_quality: Optional[float] = None 
    # Source of the target quality score (e.g., "llm_judgment", "proxy_metric_avg_sicql_q")
    target_epistemic_quality_source: Optional[str] = None 

    # --- Metadata ---
    created_at: str = "" # ISO format timestamp
    # Any other execution metadata (e.g., time taken, DSPy optimizer version)
    extra_data: Dict[str, Any] = field(default_factory=dict) 

    # --- Utility Methods ---
    def get_all_text_outputs(self) -> List[str]:
        """Get a list of all text outputs, including intermediate steps and final output."""
        texts = [step.output_text for step in self.execution_steps]
        texts.append(self.final_output_text)
        return texts

    def get_all_score_bundles(self) -> List[ScoreBundle]:
        """Get a list of all ScoreBundles, including intermediate steps and final output."""
        bundles = [step.scores for step in self.execution_steps]
        bundles.append(self.final_scores)
        return bundles

    def to_markdown(self) -> str:
        lines = [f"## Plan Trace: {self.trace_id}", f"**Goal:** {self.goal_text}\n"]
        for step in self.execution_steps:
            step_id_str = str(step.step_id) if step.step_id is not None else "N/A"
            lines.append(f"### Step {step_id_str}: {step.description}")
            lines.append(f"Output: `{step.output_text}`")
            lines.append(step.scores.to_report(f"Step {step_id_str}: Scores"))
        lines.append(f"\n**Final Output:** `{self.final_output_text}`")
        lines.append("Final Scores:")
        lines.append(self.final_scores.to_report("Trace Final Scores") if self.final_scores else "No final scores available.")
        return "\n".join(lines)

    def save_as_markdown(self, reports_dir: str = "reports") -> str:
        os.makedirs(reports_dir, exist_ok=True)
        markdown_text = self.to_markdown()
        safe_trace_id = "".join(c for c in self.trace_id if c.isalnum() or c in (' ', '-', '_')).rstrip()
        filename = f"{safe_trace_id}.md"
        filepath = os.path.join(reports_dir, filename)
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(markdown_text)
        return filepath


